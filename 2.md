# 字符串

在C语言中,可以这样定义一个ASCII字符串:

```c
char* str="Hello,World!";
char str[]="Hello,World!";
char str[13]={'H','e','l','l','o',',','W','o','r','l','d','!','\0'};
```

对于宽字符,有如下`typedef`:

```c
typedef unsigned short wchar_t;
```

可以这样定义一个宽字符串:

```c
wchar_t ch=L'L'                    //告诉编译器是一个宽字符
wchar_t* str=L"Hello,World!";
wchar_t str[]=L"Hello,World!";
```

编写一个简单的程序:

```c
#include<stdio.h>
#include<string.h>
int main(void)
{
	char str0[] = "Hello,World!";
	wchar_t str1[] = L"Hello,World!";
	printf("strlen(str0) is %zd.\n", strlen(str0));
	printf("strlen(str1) is %zd.\n", strlen(str1));
	return 0;
}
```

程序输出如下:

```shell
strlen(str0) is 12.
strlen(str1) is 1.
```

`strlen()`函数遇到宽字符串就无法正常工作了.让我们看一看宽字符串`str1`的十六进制表示,可以通过以下代码实现:

```c
char* str = str1;
for (int i = 0; i < 26; i++)
	printf("%x ", str[i]);
```

```shell
48 0 65 0 6c 0 6c 0 6f 0 2c 0 57 0 6f 0 72 0 6c 0 64 0 21 0 0 0
```

显然,`strlen()`函数把48后面的0当做字符串的结尾标记了.

`strlen()`函数也有对应的宽字符版本:`wcslen()`.

`wcslen()`返回的值是6.还记得上面的`typedef`吗?`wchar_t`就是`unsigned short`,占据2个字节.第一个`char`是0x48,而第一个`wchar_t`是0x0048,所以`wcslen()`才可以正常工作.

两个版本的字符串显然有点麻烦,我们可以使用Microsoft Visual C++中提供的tchar.h.tchar.h中定义了一系列诸如`_tprintf`的前面带有下划线的函数.如果程序中定义了`UNICODE`,那么

```c
#define _tcslen wcslen
```

如果没有定义则:

```c
#define _tcslen strlen
```

查看winnt.h头文件,`前面提到的TEXT()`宏定义结构大致如下:

```c
#ifdef UNICODE
#define __T(quote) L##quote
#else
#define __T(quote) quote
#endif
#define TEXT(quote) __T(quote)
```

其中,##将L和宏参数quote拼接在一起.
